{"imports":["./common.js"],"exports":["decodeBase64","jsDecodeBase64"],"reexports":[],"__syncModuleProgram__":"({   imports: $h͏_imports,   liveVar: $h͏_live,   onceVar: $h͏_once,   importMeta: $h͏____meta, }) => (function () { 'use strict';   let monodu64,padding;$h͏_imports([[\"./common.js\", [[\"monodu64\", [$h͏_a => (monodu64 = $h͏_a)]],[\"padding\", [$h͏_a => (padding = $h͏_a)]]]]]);   \n\n\n\n\n\n/**\n * Decodes a Base64 string into bytes, as specified in\n * https://tools.ietf.org/html/rfc4648#section-4\n *\n * XSnap is a JavaScript engine based on Moddable/XS.\n * The algorithm below is orders of magnitude too slow on this VM, but it\n * arranges a native binding on the global object.\n * We use that if it is available instead.\n *\n * This function is exported from this *file* for use in benchmarking,\n * but is not part of the *module*'s public API.\n *\n * @param {string} string Base64-encoded string\n * @param {string} [name] The name of the string as it will appear in error\n * messages.\n * @returns {Uint8Array} decoded bytes\n */\nconst        jsDecodeBase64=(string,name='<unknown>')=>{\nconst data=new Uint8Array(Math.ceil(string.length*4/3));\nlet register=0;\nlet quantum=0;\nlet i=0;/* index in string*/\nlet j=0;/* index in data*/\n\nwhile(i<string.length&&string[i]!==padding){\nconst number=monodu64[string[i]];\nif(number===undefined){\nthrow Error( `Invalid base64 character ${string[i]} in string ${name}`);\n }\nregister=register<<6|number;\nquantum+=6;\nif(quantum>=8){\nquantum-=8;\ndata[j]=register>>>quantum;\nj+=1;\nregister&=(1<<quantum)-1;\n }\ni+=1;\n }\n\nwhile(quantum>0){\nif(i===string.length||string[i]!==padding){\nthrow Error( `Missing padding at offset ${i} of string ${name}`);\n }\n/* We MAY reject non-zero padding bits, but choose not to.*/\n/* https://datatracker.ietf.org/doc/html/rfc4648#section-3.5*/\ni+=1;\nquantum-=2;\n }\n\nif(i<string.length){\nthrow Error(\n `Base64 string has trailing garbage ${string.substr(\ni)\n } in string ${name}`);\n\n }\n\nreturn data.subarray(0,j);\n };\n\n/* The XS Base64.decode function is faster, but might return ArrayBuffer (not*/\n/* Uint8Array).  Adapt it to our needs.*/$h͏_once.jsDecodeBase64(jsDecodeBase64);\nconst adaptDecoder=\n(nativeDecodeBase64)=>\n(...args)=>{\nconst decoded=nativeDecodeBase64(...args);\nif(decoded instanceof Uint8Array){\nreturn decoded;\n }\nreturn new Uint8Array(decoded);\n };\n\n/** @type {typeof jsDecodeBase64} */\nconst        decodeBase64=\nglobalThis.Base64!==undefined?\nadaptDecoder(globalThis.Base64.decode):\njsDecodeBase64;$h͏_once.decodeBase64(decodeBase64);\n})()\n","__liveExportMap__":{},"__reexportMap__":{},"__fixedExportMap__":{"jsDecodeBase64":["jsDecodeBase64"],"decodeBase64":["decodeBase64"]},"__needsImportMeta__":false}
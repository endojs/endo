/**
 * Provides {@link transformAst}
 *
 * @module
 */

import babelTraverse from '@babel/traverse';
import { evadeComment, elideComment } from './transform-comment.js';
import { makeLocationUnmapper } from './location-unmapper.js';

// TODO The following is sufficient on Node.js, but for compatibility with
// `node -r esm`, we must use the pattern below.
// Restore after https://github.com/Agoric/agoric-sdk/issues/8671.
// OR, upgrading to Babel 8 probably addresses this defect.
// const { default: traverse } = /** @type {any} */ (babelTraverse);
const traverse = /** @type {typeof import('@babel/traverse')['default']} */ (
  babelTraverse.default || babelTraverse
);

/**
 * Options for {@link transformAst}
 *
 * @internal
 * @typedef {TransformAstOptionsWithLocationUnmap | TransformAstOptionsWithoutSourceMap} TransformAstOptions
 */

/**
 * Options for {@link transformAst}
 *
 * If `useLocationUnmap` is not `true`, `sourceMap` is unused.
 *
 * @internal
 * @typedef TransformAstOptionsWithoutSourceMap
 * @property {false} [useLocationUnmap] - Enable location unmapping
 * @property {string} [sourceMap] - Original source map
 * @property {boolean} [elideComments]
 */

/**
 * Options for {@link transformAst}
 *
 * If `useLocationUnmap` is `true`, then `sourceMap` must also be present.
 *
 * @internal
 * @typedef TransformAstOptionsWithLocationUnmap
 * @property {true} useLocationUnmap - Enable location unmapping
 * @property {string} sourceMap - Original source map
 * @property {boolean} [elideComments]
 */

/**
 * Performs transformations on the given AST
 *
 * This function mutates `ast`.
 *
 * @internal
 * @param {import('@babel/types').File} ast - AST, as generated by Babel
 * @param {TransformAstOptions} [opts]
 * @returns {void}
 */
export function transformAst(
  ast,
  { sourceMap, useLocationUnmap, elideComments = false } = {},
) {
  /** @type {import('./location-unmapper.js').LocationUnmapper|undefined} */
  let unmapLoc;
  if (sourceMap && useLocationUnmap) {
    unmapLoc = makeLocationUnmapper(sourceMap, ast);
  }
  const transformComment = elideComments ? elideComment : evadeComment;
  traverse(ast, {
    enter(p) {
      const { loc, leadingComments, innerComments, trailingComments, type } =
        p.node;
      // discriminated union
      if ('comments' in p.node) {
        (p.node.comments || []).forEach(node =>
          transformComment(node, unmapLoc),
        );
      }
      // Rewrite all comments.
      (leadingComments || []).forEach(node => transformComment(node, unmapLoc));
      // XXX: there is no such Node having type matching /^Comment.+/ in
      // @babel/types
      if (type.startsWith('Comment')) {
        // @ts-expect-error - see above XXX
        transformComment(p.node, unmapLoc);
      }
      (innerComments || []).forEach(node => transformComment(node, unmapLoc));
      // If not a comment, and we are unmapping the source maps,
      // then do it for this location.
      if (unmapLoc) {
        unmapLoc(loc);
      }
      (trailingComments || []).forEach(node =>
        transformComment(node, unmapLoc),
      );
    },
  });
}

/**
 * Provides {@link transformAst}
 *
 * @module
 */

import babelTraverse from '@babel/traverse';
import { evadeComment, elideComment } from './transform-comment.js';
import {
  evadeStrings,
  evadeTemplates,
  evadeDecrementGreater,
  evadeRegexpLiteral,
} from './transform-code.js';

// TODO The following is sufficient on Node.js, but for compatibility with
// `node -r esm`, we must use the pattern below.
// Restore after https://github.com/Agoric/agoric-sdk/issues/8671.
// OR, upgrading to Babel 8 probably addresses this defect.
// const { default: traverse } = /** @type {any} */ (babelTraverse);
const traverse = /** @type {typeof import('@babel/traverse')['default']} */ (
  babelTraverse.default || babelTraverse
);

/**
 * Options for {@link transformAst}
 *
 * @internal
 * @typedef {TransformAstOptionsWithoutSourceMap} TransformAstOptions
 */

/**
 * Options for {@link transformAst}
 *
 * @internal
 * @typedef TransformAstOptionsWithoutSourceMap
 * @property {boolean} [elideComments]
 * @property {boolean} [noCodeTransforms]
 */

/**
 * Performs transformations on the given AST
 *
 * This function mutates `ast`.
 *
 * @internal
 * @param {import('@babel/types').File} ast - AST, as generated by Babel
 * @param {TransformAstOptions} [opts]
 * @returns {void}
 */
export function transformAst(
  ast,
  { elideComments = false, noCodeTransforms = false } = {},
) {
  const transformComment = elideComments ? elideComment : evadeComment;
  traverse(ast, {
    enter(p) {
      const { leadingComments, innerComments, trailingComments, type } = p.node;
      // discriminated union
      if ('comments' in p.node) {
        (p.node.comments || []).forEach(node => transformComment(node));
      }
      // Rewrite all comments.
      (leadingComments || []).forEach(node => transformComment(node));
      if (type.startsWith('Comment')) {
        transformComment(p.node);
      }
      (innerComments || []).forEach(node => transformComment(node));
      (trailingComments || []).forEach(node => transformComment(node));
      if (!noCodeTransforms) {
        evadeStrings(p);
        evadeTemplates(p);

        // Prevent `-->` from appearing in output (HTML comment end marker)
        evadeDecrementGreater(p);

        // evade import ( in RegExp literals
        evadeRegexpLiteral(p);
      }
    },
  });
}

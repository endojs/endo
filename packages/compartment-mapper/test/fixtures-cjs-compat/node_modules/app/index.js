const exportsShenanigans = require('exports-shenanigans');
const fromDebug = require('exports-shenanigans/from-debug');
const exportsThis = require('exports-shenanigans/exports-this');
const interops = require('interops');
const moduleinterops = require('./moduleinterops');
const stableOrderJson = require('./assertion-generators/json.cjs');
const cycle1 = require('./cycle1');
const defineprop = require('defineprop');
const parserStruggles = require('parser-struggles');
const afterExec = require('after-exec');
require('default-difficulties');
const nestedFile = require('nested-file/nested');
const nestedExport = require('nested-export/callBound');
const requireResolvePaths = require('require-resolve');

// Generated by running v16.13.2: node assertion-generators/expected.cjs
// I chose this behavior because:
//  - it's more likely to occur in cjs codebase,
//  - it doesn't seem possible/reasonable to implement both behaviors depending on how the module is loaded,
const whatWouldNodejsRequireDo =
  '{"default":{"nameCollision":1},"nameCollision":3,"notDefault":2}';

// Would we rather reproduce the import behavior? see assertion-generators/expected.mjs
// const whatWouldNodejsImportDo = '{"default":{"default":{"nameCollision":1},"nameCollision":3,"notDefault":2},"nameCollision":3,"notDefault":2}'

function assertInteropNameCollisions({ moduleReference, expect, name }) {
  const whatWeGot = stableOrderJson(moduleReference);
  if (whatWeGot !== expect) {
    throw Error(`Exporting a field called 'default' from a cjs module '${name}' should not override all other fields.
    What we got     : ${whatWeGot}
    What we expected: ${expect}`);
  }
}
module.exports.results = {
  requireResolvePaths
};

module.exports.assertions = {
  packageNestedFile() {
    if(!nestedFile.isOk){
      throw Error('Expected nested-file/nested to have been resolved based on path')
    }
    if(!nestedExport.isOk){
      throw Error('Expected nested-export/callBound to have been resolved based on exports defined in package.json')
    }
  },
  defaultChangesAfterExec() {
    if (!afterExec.isOk) {
      throw Error('Expected a.js to be the same thing when required twice');
    }
  },
  packageWithDefineProperty() {
    if (!defineprop.isOk) {
      throw Error('Expected exports created by defineProperty to be available');
    }
  },
  moduleWithCycle() {
    if (!cycle1.isOk) {
      throw Error(
        'Modules depending on each other in a cycle failed to get references from exports',
      );
    }
  },
  parserStruggles() {
    if (!parserStruggles.isOk) {
      throw Error(
        'Failed to get exports from nested require and no errors ocurred in the process.',
      );
    }
  },
  packageWithDefaultField() {
    assertInteropNameCollisions({
      name: 'interops',
      moduleReference: interops,
      expect: whatWouldNodejsRequireDo,
    });
  },
  moduleWithDefaultField() {
    assertInteropNameCollisions({
      name: 'moduleinterops',
      moduleReference: moduleinterops,
      expect: whatWouldNodejsRequireDo,
    });
  },
  packageExportsShenanigans() {
    try {
      exportsShenanigans.makeTheCall();
    } catch (e) {
      throw Error(
        'Referencing exported functions should be possible. ' + e.message,
      );
    }
    if(!fromDebug.isOk) {
      throw Error(`Overwriting exports with derivation of exports should work. exports-shenanigans/from-debug fixture did not load.`)
    }
    if (exportsThis.magicNumber !== 2) {
      throw Error('Top-level "this" should be a reference to module.exports');
    }
  },
};

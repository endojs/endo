/**
 * @import {PackageDescriptor} from '../../../../src/types.js'
 */

/**
 * @typedef {(filepath: string, packageDescriptor: PackageDescriptor) => unknown} FoldFn
 * @typedef {Array<{packageDescriptor: PackageDescriptor, sources: string[]}>} PantsHeap
 * @typedef {Array<{packageDescriptor: PackageDescriptor, foldedSources: unknown[]}>} FoldedPantsHeap
 */

/**
 * @overload
 * @param {PantsHeap} pantsHeap Information about sources to provide to loaders
 * @param {[string, ...string[]]} pantsFolders pantsFolder names
 * @returns {FoldedPantsHeap}
 */

/**
 * @overload
 * @param {PantsHeap} pantsHeap Information about sources to provide to loaders
 * @param {string[]} [pantsFolders] pantsFolder names
 * @returns {PantsHeap|FoldedPantsHeap}
 */

/**
 * @param {PantsHeap} pantsHeap Information about sources to provide to loaders
 * @param {string[]} [pantsFolders] pantsFolder names
 * @returns {PantsHeap|FoldedPantsHeap}
 */
const foldPantsFolders = (pantsHeap, pantsFolders = []) =>
  pantsFolders.length
    ? pantsFolders.flatMap(pantsFolder => {
        /** @type {string} */
        let pantsFolderPath;
        try {
          pantsFolderPath = require.resolve(pantsFolder);
        } catch (err) {
          throw Error(`Could not resolve pantsFolder "${pantsFolder}"`, {
            cause: err,
          });
        }

        /** @type {FoldFn} */
        let fold;
        /** @type {string[]} */
        let extensions;

        try {
          /** @type {{fold: FoldFn, extensions: string[]}} */
          ({ fold, extensions } = require(pantsFolderPath));
        } catch (err) {
          throw Error(
            `Could not require pantsFolder "${pantsFolder}" via ${pantsFolderPath}: ${err.message}`,
            { cause: err },
          );
        }

        if (typeof fold !== 'function') {
          throw Error(
            `Expected pantsFolder "${pantsFolder}" via ${pantsFolderPath} to export a fold() function; got ${fold}`,
          );
        }

        if (!Array.isArray(extensions) || extensions.length === 0) {
          throw Error(
            `Expected pantsFolder "${pantsFolder}" via ${pantsFolderPath} to export a non-empty array of file extensions; got ${extensions}`,
          );
        }

        // find all sources matching the extensions, then call fold() on each
        const foldedPantsHeap = pantsHeap.map(
          ({ packageDescriptor, sources }) => {
            const sourcesForLoader = sources.filter(source =>
              extensions.some(ext => source.endsWith(ext)),
            );
            const foldedSources = sourcesForLoader.map(source => {
              try {
                return fold(source, packageDescriptor);
              } catch (err) {
                throw Error(
                  `Error folding source "${source}" for package "${packageDescriptor.name}": ${err.message}`,
                  { cause: err },
                );
              }
            });
            return { packageDescriptor, foldedSources };
          },
        );

        return foldedPantsHeap;
      })
    : pantsHeap;

exports.foldPantsFolders = foldPantsFolders;

import 'ses';
import test from 'ava';
import fs from 'fs';
import crypto from 'crypto';
import url from 'url';
import { importLocation, parseArchive, makeArchive } from '../index.js';
import { makeReadPowers } from '../node-powers.js';

const fixtureLocation = new URL(
  'fixtures-stack/index.js',
  import.meta.url,
).toString();

const readPowers = makeReadPowers({ fs, crypto, url });

// This test confirms that the stack trace generated by an error in an archive
// will be influenced by the sourceURL assigned by the importer from the stable
// information in the compartment map, in a format that VS Code at least
// recognizes in the Terminal window and will click through to the line and
// column of the matching file in the workspace.
test('archive stack trace source', async t => {
  const archive = await makeArchive(readPowers, fixtureLocation);
  const app = await parseArchive(archive);

  let error;
  try {
    await app.import();
  } catch (_error) {
    error = _error;
  }

  t.assert(error);
  t.log(error.stack);
  t.assert(
    error.stack.includes(
      '.../compartment-mapper/test/fixtures-stack/index.js:3:',
    ),
  );
});

// Whereas, we expect the same program executed directly from local files to
// have a fully qualified file URL in the stack trace.
test('disk stack trace source', async t => {
  await null;
  let error;
  try {
    await importLocation(readPowers, fixtureLocation);
  } catch (_error) {
    error = _error;
  }

  t.assert(error);
  t.log(error.stack);
  t.assert(
    error.stack.includes(
      '/packages/compartment-mapper/test/fixtures-stack/index.js:3:',
    ),
  );
});

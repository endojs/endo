/* global globalThis */
/// <reference types="ses"/>

import { harden } from '@endo/harden';
import { Fail } from '@endo/errors';
import { decodeBase64 } from '@endo/base64';
import { parseArchive } from '@endo/compartment-mapper/import-archive.js';
import { wrapInescapableCompartment } from './compartment-wrapper.js';

/**
 * The bundle importer is designed for (serializable) source modules but can
 * accomodate native module exports (unserializable) too in a 'test' format.
 * @typedef {import('@endo/bundle-source').ModuleFormat | 'test'} ImportableBundleFormat
 */

/**
 * The bundle importer is designed for (serializable) source modules but can
 * accomodate native module exports (unserializable) too in a 'test' format.
 * @typedef {import('@endo/bundle-source').BundleSourceResult<any> | {moduleFormat: 'test'}} ImportableBundle
 */

// Adding a type signature in-place proved difficult to migrate in-place.
// See typedImportBundle below.
export async function importBundle(bundle, options = {}, powers = {}) {
  await null;
  const {
    bundleUrl = undefined,
    filePrefix,
    endowments: optEndowments = {},
    // transforms are indeed __shimTransforms__, intended to apply to both
    // evaluated programs and modules shimmed to programs.
    transforms = [],
    inescapableTransforms = [],
    inescapableGlobalProperties = {},
    expectedSha512 = undefined,
    importHook = undefined,
  } = options;
  const {
    computeSha512 = undefined,
    computeSourceLocation = undefined,
    computeSourceMapLocation = undefined,
  } = powers;
  const endowments = {
    TextEncoder,
    TextDecoder,
    URL: globalThis.URL, // Absent only in XSnap
    Base64: globalThis.Base64, // Present only in XSnap
    atob: globalThis.atob,
    btoa: globalThis.btoa,
    ...optEndowments,
  };

  let CompartmentToUse = Compartment;
  if (
    inescapableTransforms.length ||
    Object.keys(inescapableGlobalProperties).length
  ) {
    // @ts-expect-error TS2322 no match for the signature
    CompartmentToUse = wrapInescapableCompartment(
      Compartment,
      inescapableTransforms,
      inescapableGlobalProperties,
    );
  }

  let compartment;

  assert('moduleFormat' in bundle);
  const { moduleFormat } = bundle;
  if (moduleFormat === 'endoZipBase64') {
    assert('endoZipBase64' in bundle);
    const { endoZipBase64 } = bundle;
    const bytes = decodeBase64(endoZipBase64);
    const archive = await parseArchive(bytes, bundleUrl, {
      computeSha512,
      expectedSha512,
      computeSourceLocation,
      computeSourceMapLocation,
      importHook,
    });
    // Call import by property to bypass SES censoring for dynamic import.
    // eslint-disable-next-line dot-notation
    const { namespace } = await archive['import']({
      globals: endowments,
      __shimTransforms__: transforms,
      Compartment: CompartmentToUse,
      importHook,
    });
    // namespace.default has the default export
    return namespace;
  }

  // The 'test' format is not generated by bundleSource and is not
  // serializable as JSON and is not passable because copy-records cannot have symbol keys.
  if (moduleFormat === 'test') {
    const exports = bundle[Symbol.for('exports')];
    if (exports === undefined) {
      throw new Error(
        'Cannot import bundle with moduleFormat "test" that lacks an symbol-named property @exports and has likely been partially transported via JSON or eventual-send',
      );
    }

    // We emulate a module exports namespace object, which has certain invariants:
    // Property names are only strings, so we will ignore symbol-named properties.
    // All properties are enumerable, so we will ignore non-enumerable properties.
    // All properties should be writable, but we deliberately deviate rather than
    // emulate the exotic behavior of standard module exports namespace objects.
    // The namespace object is sealed.
    // Because we deviate from the standard behavior, the namespace object is
    // frozen by implication.
    // We capture the value for each property now and never again consult the given exports object.
    return Object.seal(
      Object.create(
        null,
        Object.fromEntries([
          ...Object.entries(Object.getOwnPropertyDescriptors(exports))
            // eslint-disable-next-line no-nested-ternary
            .sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))
            .filter(
              ([name, descriptor]) =>
                typeof name === 'string' && descriptor.enumerable,
            )
            .map(([name]) => [
              name,
              {
                value: exports[name],
                writable: false,
                enumerable: true,
                configurable: false,
              },
            ]),
          [
            Symbol.toStringTag,
            {
              value: 'Module',
              writable: false,
              enumerable: false,
              configurable: false,
            },
          ],
        ]),
      ),
    );
  }

  assert('source' in bundle);
  let { source } = bundle;
  const sourceMap = 'sourceMap' in bundle ? bundle.sourceMap : '';
  if (moduleFormat === 'getExport') {
    // The 'getExport' format is a string which defines a wrapper function
    // named `getExport()`. This function provides a `module` to the
    // linearized source file, executes that source, then returns
    // `module.exports`. To get the function object out of a program-mode
    // evaluation, we must wrap the function definition in parentheses
    // (making it an expression). We also want to append the `sourceMap`
    // comment so `evaluate` can attach useful debug information. Finally, to
    // extract the namespace object, we need to invoke this function.
    source = `(${source})\n${sourceMap}`;
  } else if (moduleFormat === 'nestedEvaluate') {
    // The 'nestedEvaluate' format is similar, except the wrapper function
    // (now named `getExportWithNestedEvaluate`) wraps more than a single
    // linearized string. Each source module is processed (converting
    // `import` into `require`) and added to a table named `sourceBundle`.
    // Each module will be evaluated separately (so they can get distinct
    // sourceMap strings), using a mandatory endowment named
    // `nestedEvaluate`. The wrapper function should be called with
    // `filePrefix`, which will be used as the sourceMap for the top-level
    // module. The sourceMap name for other modules will be derived from
    // `filePrefix` and the relative import path of each module.
    endowments.nestedEvaluate = src => compartment.evaluate(src);
    source = `(${source})\n${sourceMap}`;
  } else if (moduleFormat === 'endoScript') {
    // The 'endoScript' format is just a script.
  } else {
    Fail`unrecognized moduleFormat '${moduleFormat}'`;
  }

  compartment = new CompartmentToUse(endowments, {}, { transforms });
  harden(compartment.globalThis);
  const result = compartment.evaluate(source);
  if (moduleFormat === 'endoScript') {
    // The completion value of an 'endoScript' is the namespace.
    // This format does not curry the filePrefix.
    return result;
  } else {
    // The 'getExport' and 'nestedEvaluate' formats curry a filePrefix.
    const namespace = result(filePrefix);
    // namespace.default has the default export
    return namespace;
  }
}

/**
 * typedImportBundle<Expected> takes the output of `bundleSource` or
 * `bundleTestExports`, and returns a namespace object, with .default, and
 * maybe other properties for named exports.
 *
 * This is the intended signature but produces a type that is not suitable
 * in integration with legacy code of Agoric SDK.
 *
 * @template [T=any]
 * @param {ImportableBundle} bundle
 * @param {object} [options]
 * @param {object} [powers]
 * @returns {Promise<T>}
 */
export const typedImportBundle = importBundle;

/**
 * A utility function for producing test bundles, which are not serializable
 * as JSON or passable.
 * @param {Record<PropertyKey, unknown>} exports
 */
export const bundleTestExports = exports => {
  const symbols = Object.getOwnPropertySymbols(exports).filter(
    name => name !== Symbol.toStringTag,
  );
  symbols.length > 0 &&
    Fail`exports must not have symbol-named properties, got: ${symbols.map(String).join(', ')}`;
  return {
    moduleFormat: 'test',
    [Symbol.for('exports')]: exports,
  };
};

/*
importBundle(bundle, { metering: { getMeter, meteringOptions } });
importBundle(bundle, { transforms: [ meterTransform ], lexicals: { getMeter } });
importBundle(bundle, { mandatoryTransforms: [ meterTransform ], mandatoryLexicals: { getMeter } });
 // then importBundle builds the Compartment wrapper

XS:

xs.setMeter();
xs.callWithMeter(meter, ns.dispatch);
xs.callWithKeeper(keeper, ns.dispatch); // keeper.getMeter() -> meter, then ns.dispatch()
// keeper.startCrank(metadata.tshirtsize)
//   // keeper sets meter to some fixed value
// initialMeter = keeper.getMeter()
// ns.dispatch() // drains initialMeter
// maybe: keeper.endCrank() ???



*/

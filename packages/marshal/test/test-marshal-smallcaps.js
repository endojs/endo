// @ts-check

import { test } from './prepare-test-env-ava.js';

import { makeMarshal } from '../src/marshal.js';

import { roundTripPairs } from './test-marshal.js';

const { freeze, isFrozen, create, prototype: objectPrototype } = Object;

// this only includes the tests that do not use liveSlots

const makeTestMarshal = () =>
  makeMarshal(undefined, undefined, {
    errorTagging: 'off',
    useSmallcaps: true,
  });

test('smallcaps serialize unserialize round trip half pairs', t => {
  const { serialize, unserialize } = makeTestMarshal();
  for (const [plain, _] of roundTripPairs) {
    const { body } = serialize(plain);
    const decoding = unserialize({ body, slots: [] });
    t.deepEqual(decoding, plain);
    t.assert(isFrozen(decoding));
  }
});

test('smallcaps serialize static data', t => {
  const { serialize } = makeTestMarshal();
  const ser = val => serialize(val);
  t.throws(() => ser([1, 2]), {
    message: /Cannot pass non-frozen objects like/,
  });
  // -0 serialized as 0
  t.deepEqual(ser(0), { body: '#0', slots: [] });
  t.deepEqual(ser(-0), { body: '#0', slots: [] });
  t.deepEqual(ser(-0), ser(0));
  // unregistered symbols
  t.throws(() => ser(Symbol('sym2')), {
    // An anonymous symbol is not Passable
    message: /Only registered symbols or well-known symbols are passable:/,
  });

  const cd = ser(harden([1, 2]));
  t.is(isFrozen(cd), true);
  t.is(isFrozen(cd.slots), true);
});

test('smallcaps unserialize static data', t => {
  const { unserialize } = makeTestMarshal();
  const uns = body => unserialize({ body, slots: [] });

  // should be frozen
  const arr = uns('#[1,2]');
  t.truthy(isFrozen(arr));
  const a = uns('#{"b":{"c":{"d": []}}}');
  t.truthy(isFrozen(a));
  t.truthy(isFrozen(a.b));
  t.truthy(isFrozen(a.b.c));
  t.truthy(isFrozen(a.b.c.d));
});

test('smallcaps serialize errors', t => {
  const { serialize } = makeTestMarshal();
  const ser = val => serialize(val);

  t.deepEqual(ser(harden(Error())), {
    body: '#{"@qclass":"error","message":"","name":"Error"}',
    slots: [],
  });

  t.deepEqual(ser(harden(ReferenceError('msg'))), {
    body: '#{"@qclass":"error","message":"msg","name":"ReferenceError"}',
    slots: [],
  });

  // TODO Once https://github.com/Agoric/SES-shim/issues/579 is merged
  // do a golden of the error notes generated by the following

  // Extra properties
  const errExtra = Error('has extra properties');
  // @ts-ignore Check dynamic consequences of type violation
  errExtra.foo = [];
  freeze(errExtra);
  t.assert(isFrozen(errExtra));
  // @ts-ignore Check dynamic consequences of type violation
  t.falsy(isFrozen(errExtra.foo));
  t.deepEqual(ser(errExtra), {
    body:
      '#{"@qclass":"error","message":"has extra properties","name":"Error"}',
    slots: [],
  });
  // @ts-ignore Check dynamic consequences of type violation
  t.falsy(isFrozen(errExtra.foo));

  // Bad prototype and bad "message" property
  const nonErrorProto1 = { __proto__: Error.prototype, name: 'included' };
  const nonError1 = { __proto__: nonErrorProto1, message: [] };
  t.deepEqual(ser(harden(nonError1)), {
    body: '#{"@qclass":"error","message":"","name":"included"}',
    slots: [],
  });
});

test('smallcaps unserialize errors', t => {
  const { unserialize } = makeTestMarshal();
  const uns = body => unserialize({ body, slots: [] });

  const em1 = uns(
    '#{"@qclass":"error","message":"msg","name":"ReferenceError"}',
  );
  t.truthy(em1 instanceof ReferenceError);
  t.is(em1.message, 'msg');
  t.truthy(isFrozen(em1));

  const em2 = uns('#{"@qclass":"error","message":"msg2","name":"TypeError"}');
  t.truthy(em2 instanceof TypeError);
  t.is(em2.message, 'msg2');

  const em3 = uns('#{"@qclass":"error","message":"msg3","name":"Unknown"}');
  t.truthy(em3 instanceof Error);
  t.is(em3.message, 'msg3');
});

test('smallcaps mal-formed @qclass', t => {
  const { unserialize } = makeTestMarshal();
  const uns = body => unserialize({ body, slots: [] });
  t.throws(() => uns('#{"@qclass": 0}'), { message: /invalid sclass/ });
});

test('smallcaps records', t => {
  function convertValToSlot(_val) {
    return 'slot';
  }
  const fauxPresence = harden({});
  function convertSlotToVal(_slot) {
    return fauxPresence;
  }
  const { serialize: ser, unserialize: unser } = makeMarshal(
    convertValToSlot,
    convertSlotToVal,
    {
      errorTagging: 'off',
      useSmallcaps: true,
    },
  );

  const emptyData = { body: '#{}', slots: [] };

  function build(...opts) {
    const props = {};
    for (const opt of opts) {
      if (opt === 'enumStringData') {
        props.key1 = { enumerable: true, value: 'data' };
      } else if (opt === 'enumStringGetData') {
        props.enumStringGetData = { enumerable: true, get: () => 0 };
      } else if (opt === 'enumStringGetFunc') {
        props.enumStringGetFunc = { enumerable: true, get: () => () => 0 };
      } else if (opt === 'enumStringSet') {
        props.enumStringSet = { enumerable: true, set: () => undefined };
      } else if (opt === 'nonenumStringData') {
        props.nonEnumStringData = { enumerable: false, value: 3 };
      } else {
        throw Error(`unknown option ${opt}`);
      }
    }
    // @ts-ignore Don't yet understand typing, but want dynamic test anyway
    const o = create(objectPrototype, props);
    return harden(o);
  }

  function shouldThrow(opts, message = /XXX/) {
    t.throws(() => ser(build(...opts)), { message });
  }
  const REC_NOACC = /must not be an accessor property:/;
  const REC_ONLYENUM = /must be an enumerable property:/;

  // empty objects

  // rejected because it is not hardened
  t.throws(
    () => ser({}),
    { message: /Cannot pass non-frozen objects/ },
    'non-frozen data cannot be serialized',
  );

  // harden({})
  t.deepEqual(ser(build()), emptyData);

  const key1Data = { body: '#{"key1":"data"}', slots: [] };

  // Serialized data should roundtrip properly
  t.deepEqual(unser(ser(harden({}))), {});
  t.deepEqual(unser(ser(harden({ key1: 'data' }))), { key1: 'data' });

  // unserialized data can be serialized again
  t.deepEqual(ser(unser(emptyData)), emptyData);
  t.deepEqual(ser(unser(key1Data)), key1Data);

  // { key: data }
  // all: pass-by-copy without warning
  t.deepEqual(ser(build('enumStringData')), {
    body: '#{"key1":"data"}',
    slots: [],
  });

  // anything with getters is rejected
  shouldThrow(['enumStringGetData'], REC_NOACC);
  shouldThrow(['enumStringGetData', 'enumStringData'], REC_NOACC);
  shouldThrow(['enumStringGetFunc'], REC_NOACC);
  shouldThrow(['enumStringGetFunc', 'enumStringData'], REC_NOACC);
  shouldThrow(['enumStringSet'], REC_NOACC);
  shouldThrow(['enumStringSet', 'enumStringData'], REC_NOACC);

  // anything with non-enumerable properties is rejected
  shouldThrow(['nonenumStringData'], REC_ONLYENUM);
  shouldThrow(['nonenumStringData', 'enumStringData'], REC_ONLYENUM);
});

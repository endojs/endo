// @ts-check

import { test } from './prepare-test-env-ava.js';

import { makeMarshal } from '../src/marshal.js';

import { roundTripPairs } from './test-marshal.js';

const { freeze, isFrozen, create, prototype: objectPrototype } = Object;

// this only includes the tests that do not use liveSlots

const makeTestMarshal = () =>
  makeMarshal(undefined, undefined, {
    errorTagging: 'off',
    useSmallcaps: true,
  });

/**
 * A test case to illustrate each of the encodings
 * `'` - escaped string
 * `+` - non-negative bigint
 * `-` - negative bigint
 * `#` - constant
 * `@` - symbol
 * `$` - remotable
 * `?` - promise
 */
test('encoding examples', t => {
  const { serialize } = makeTestMarshal();
  const assertSer = (val, expected, message) =>
    t.deepEqual(serialize(val), expected, message);

  // Numbers
  assertSer(0, { body: '#0', slots: [] }, 'zero');
  assertSer(500n, { body: '#"+500n"', slots: [] }, 'bigint');
  assertSer(-400n, { body: '#"-400n"', slots: [] }, '-bigint');

  // Constants
  assertSer(NaN, { body: '#"#NaN"', slots: [] }, 'NaN');
  assertSer(Infinity, { body: '#"#Infinity"', slots: [] }, 'Infinity');
  assertSer(-Infinity, { body: '#"#-Infinity"', slots: [] }, '-Infinity');
  assertSer(undefined, { body: '#"#undefined"', slots: [] }, 'undefined');

  // Strings
  assertSer('unescaped', { body: '#"unescaped"', slots: [] }, 'unescaped');
  assertSer('#escaped', { body: `#"'#escaped"`, slots: [] }, 'escaped #');
  assertSer('+escaped', { body: `#"'+escaped"`, slots: [] }, 'escaped +');
  assertSer('-escaped', { body: `#"'-escaped"`, slots: [] }, 'escaped -');
  assertSer('@escaped', { body: `#"'@escaped"`, slots: [] }, 'escaped @');

  // Symbols
  assertSer(Symbol.iterator, { body: '#"@@@iterator"', slots: [] }, 'symbol');
  assertSer(Symbol.for('foo'), { body: '#"@foo"', slots: [] }, 'reg symbol');

  assertSer(harden([1, 2]), { body: '#[1,2]', slots: [] }, 'array');
});

test('smallcaps serialize unserialize round trip half pairs', t => {
  const { serialize, unserialize } = makeTestMarshal();
  for (const [plain, _] of roundTripPairs) {
    const { body } = serialize(plain);
    const decoding = unserialize({ body, slots: [] });
    t.deepEqual(decoding, plain);
    t.assert(isFrozen(decoding));
  }
});

test('smallcaps serialize static data', t => {
  const { serialize } = makeTestMarshal();
  const ser = val => serialize(val);
  t.throws(() => ser([1, 2]), {
    message: /Cannot pass non-frozen objects like/,
  });
  // -0 serialized as 0
  t.deepEqual(ser(0), { body: '#0', slots: [] });
  t.deepEqual(ser(-0), { body: '#0', slots: [] });
  t.deepEqual(ser(-0), ser(0));
  // unregistered symbols
  t.throws(() => ser(Symbol('sym2')), {
    // An anonymous symbol is not Passable
    message: /Only registered symbols or well-known symbols are passable:/,
  });

  const cd = ser(harden([1, 2]));
  t.is(isFrozen(cd), true);
  t.is(isFrozen(cd.slots), true);
});

test('smallcaps unserialize static data', t => {
  const { unserialize } = makeTestMarshal();
  const uns = body => unserialize({ body, slots: [] });

  // should be frozen
  const arr = uns('#[1,2]');
  t.truthy(isFrozen(arr));
  const a = uns('#{"b":{"c":{"d": []}}}');
  t.truthy(isFrozen(a));
  t.truthy(isFrozen(a.b));
  t.truthy(isFrozen(a.b.c));
  t.truthy(isFrozen(a.b.c.d));
});

test('smallcaps serialize errors', t => {
  const { serialize } = makeTestMarshal();
  const ser = val => serialize(val);

  t.deepEqual(ser(harden(Error())), {
    body: '#{"@qclass":"error","message":"","name":"Error"}',
    slots: [],
  });

  t.deepEqual(ser(harden(ReferenceError('msg'))), {
    body: '#{"@qclass":"error","message":"msg","name":"ReferenceError"}',
    slots: [],
  });

  // TODO Once https://github.com/Agoric/SES-shim/issues/579 is merged
  // do a golden of the error notes generated by the following

  // Extra properties
  const errExtra = Error('has extra properties');
  // @ts-ignore Check dynamic consequences of type violation
  errExtra.foo = [];
  freeze(errExtra);
  t.assert(isFrozen(errExtra));
  // @ts-ignore Check dynamic consequences of type violation
  t.falsy(isFrozen(errExtra.foo));
  t.deepEqual(ser(errExtra), {
    body:
      '#{"@qclass":"error","message":"has extra properties","name":"Error"}',
    slots: [],
  });
  // @ts-ignore Check dynamic consequences of type violation
  t.falsy(isFrozen(errExtra.foo));

  // Bad prototype and bad "message" property
  const nonErrorProto1 = { __proto__: Error.prototype, name: 'included' };
  const nonError1 = { __proto__: nonErrorProto1, message: [] };
  t.deepEqual(ser(harden(nonError1)), {
    body: '#{"@qclass":"error","message":"","name":"included"}',
    slots: [],
  });
});

test('smallcaps unserialize errors', t => {
  const { unserialize } = makeTestMarshal();
  const uns = body => unserialize({ body, slots: [] });

  const em1 = uns(
    '#{"@qclass":"error","message":"msg","name":"ReferenceError"}',
  );
  t.truthy(em1 instanceof ReferenceError);
  t.is(em1.message, 'msg');
  t.truthy(isFrozen(em1));

  const em2 = uns('#{"@qclass":"error","message":"msg2","name":"TypeError"}');
  t.truthy(em2 instanceof TypeError);
  t.is(em2.message, 'msg2');

  const em3 = uns('#{"@qclass":"error","message":"msg3","name":"Unknown"}');
  t.truthy(em3 instanceof Error);
  t.is(em3.message, 'msg3');
});

test('smallcaps mal-formed @qclass', t => {
  const { unserialize } = makeTestMarshal();
  const uns = body => unserialize({ body, slots: [] });
  t.throws(() => uns('#{"@qclass": 0}'), { message: /invalid sclass/ });
});

test('smallcaps records', t => {
  function convertValToSlot(_val) {
    return 'slot';
  }
  const fauxPresence = harden({});
  function convertSlotToVal(_slot) {
    return fauxPresence;
  }
  const { serialize: ser, unserialize: unser } = makeMarshal(
    convertValToSlot,
    convertSlotToVal,
    {
      errorTagging: 'off',
      useSmallcaps: true,
    },
  );

  const emptyData = { body: '#{}', slots: [] };

  function build(...opts) {
    const props = {};
    for (const opt of opts) {
      if (opt === 'enumStringData') {
        props.key1 = { enumerable: true, value: 'data' };
      } else if (opt === 'enumStringGetData') {
        props.enumStringGetData = { enumerable: true, get: () => 0 };
      } else if (opt === 'enumStringGetFunc') {
        props.enumStringGetFunc = { enumerable: true, get: () => () => 0 };
      } else if (opt === 'enumStringSet') {
        props.enumStringSet = { enumerable: true, set: () => undefined };
      } else if (opt === 'nonenumStringData') {
        props.nonEnumStringData = { enumerable: false, value: 3 };
      } else {
        throw Error(`unknown option ${opt}`);
      }
    }
    // @ts-ignore Don't yet understand typing, but want dynamic test anyway
    const o = create(objectPrototype, props);
    return harden(o);
  }

  function shouldThrow(opts, message = /XXX/) {
    t.throws(() => ser(build(...opts)), { message });
  }
  const REC_NOACC = /must not be an accessor property:/;
  const REC_ONLYENUM = /must be an enumerable property:/;

  // empty objects

  // rejected because it is not hardened
  t.throws(
    () => ser({}),
    { message: /Cannot pass non-frozen objects/ },
    'non-frozen data cannot be serialized',
  );

  // harden({})
  t.deepEqual(ser(build()), emptyData);

  const key1Data = { body: '#{"key1":"data"}', slots: [] };

  // Serialized data should roundtrip properly
  t.deepEqual(unser(ser(harden({}))), {});
  t.deepEqual(unser(ser(harden({ key1: 'data' }))), { key1: 'data' });

  // unserialized data can be serialized again
  t.deepEqual(ser(unser(emptyData)), emptyData);
  t.deepEqual(ser(unser(key1Data)), key1Data);

  // { key: data }
  // all: pass-by-copy without warning
  t.deepEqual(ser(build('enumStringData')), {
    body: '#{"key1":"data"}',
    slots: [],
  });

  // anything with getters is rejected
  shouldThrow(['enumStringGetData'], REC_NOACC);
  shouldThrow(['enumStringGetData', 'enumStringData'], REC_NOACC);
  shouldThrow(['enumStringGetFunc'], REC_NOACC);
  shouldThrow(['enumStringGetFunc', 'enumStringData'], REC_NOACC);
  shouldThrow(['enumStringSet'], REC_NOACC);
  shouldThrow(['enumStringSet', 'enumStringData'], REC_NOACC);

  // anything with non-enumerable properties is rejected
  shouldThrow(['nonenumStringData'], REC_ONLYENUM);
  shouldThrow(['nonenumStringData', 'enumStringData'], REC_ONLYENUM);
});
